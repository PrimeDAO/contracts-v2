{
  "language": "Solidity",
  "sources": {
    "contracts/utils/SignerV2.sol": {
      "content": "/*\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n// Signer contract. Enables signing transaction before sending it to Gnosis Safe.\n// Copyright (C) 2021 PrimeDao\n\n// solium-disable linebreak-style\npragma solidity 0.8.9;\n\nimport \"./interface/Safe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\n\n/**\n * @title PrimeDAO Signer Contract\n * @dev   Enables signing approved function signature transaction before sending it to Gnosis Safe.\n */\ncontract SignerV2 is ISignatureValidator {\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x7a9f5b2bf4dbb53eb85e012c6094a3d71d76e5bfe821f44ab63ed59311264e35;\n    bytes32 private constant MSG_TYPEHASH =\n        0xa1a7ad659422d5fc08fdc481fd7d8af8daf7993bc4e833452b0268ceaab66e5d; // mapping for msg typehash\n\n    mapping(bytes32 => bytes32) public approvedSignatures;\n\n    /* solium-disable */\n    address public safe;\n    mapping(address => mapping(bytes4 => bool)) public allowedTransactions;\n    /* solium-enable */\n\n    event SignatureCreated(bytes signature, bytes32 indexed hash);\n\n    modifier onlySafe() {\n        require(msg.sender == safe, \"Signer: only safe functionality\");\n        _;\n    }\n\n    /**\n     * @dev                       Signer Constructor\n     * @param _safe               Gnosis Safe address.\n     * @param _contracts          array of contract addresses\n     * @param _functionSignatures array of function signatures\n     */\n    constructor(\n        address _safe,\n        address[] memory _contracts,\n        bytes4[] memory _functionSignatures\n    ) {\n        require(_safe != address(0), \"Signer: Safe address zero\");\n        safe = _safe;\n        for (uint256 i; i < _contracts.length; i++) {\n            require(\n                _contracts[i] != address(0),\n                \"Signer: contract address zero\"\n            );\n            require(\n                _functionSignatures[i] != bytes4(0),\n                \"Signer: function signature zero\"\n            );\n            allowedTransactions[_contracts[i]][_functionSignatures[i]] = true;\n        }\n    }\n\n    /**\n     * @dev                   Signature generator\n     * @param _to             receiver address.\n     * @param _value          value in wei.\n     * @param _data           encoded transaction data.\n     * @param _operation      type of operation call.\n     * @param _safeTxGas      safe transaction gas for gnosis safe.\n     * @param _baseGas        base gas for gnosis safe.\n     * @param _gasPrice       gas price for gnosis safe transaction.\n     * @param _gasToken       token which gas needs to paid for gnosis safe transaction.\n     * @param _refundReceiver address account to receive refund for remaining gas.\n     * @param _nonce          gnosis safe contract nonce.\n     */\n    function generateSignature(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        Enum.Operation _operation,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address _refundReceiver,\n        uint256 _nonce\n    ) external returns (bytes memory signature, bytes32 hash) {\n        // check if transaction parameters are correct\n        require(\n            allowedTransactions[_to][_getFunctionHashFromData(_data)],\n            \"Signer: invalid function\"\n        );\n        require(\n            _value == 0 &&\n                _refundReceiver == address(0) &&\n                _operation == Enum.Operation.Call,\n            \"Signer: invalid arguments\"\n        );\n\n        // get contractTransactionHash from gnosis safe\n        hash = Safe(safe).getTransactionHash(\n            _to,\n            0,\n            _data,\n            _operation,\n            _safeTxGas,\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            _nonce\n        );\n\n        bytes memory paddedAddress = bytes.concat(\n            bytes12(0),\n            bytes20(address(this))\n        );\n        bytes memory messageHash = _encodeMessageHash(hash);\n        // check if transaction is not signed before\n        // solhint-disable-next-line reason-string\n        require(\n            approvedSignatures[hash] != keccak256(messageHash),\n            \"Signer: transaction already signed\"\n        );\n\n        // generate signature and add it to approvedSignatures mapping\n        signature = bytes.concat(\n            paddedAddress,\n            bytes32(uint256(65)),\n            bytes1(0),\n            bytes32(uint256(messageHash.length)),\n            messageHash\n        );\n        approvedSignatures[hash] = keccak256(messageHash);\n        emit SignatureCreated(signature, hash);\n    }\n\n    /**\n     * @dev                Validate signature using EIP1271\n     * @param _data        Encoded transaction hash supplied to verify signature.\n     * @param _signature   Signature that needs to be verified.\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature)\n        public\n        view\n        override\n        returns (bytes4)\n    {\n        if (_data.length == 32) {\n            bytes32 hash;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                hash := mload(add(_data, 32))\n            }\n            if (approvedSignatures[hash] == keccak256(_signature)) {\n                return EIP1271_MAGIC_VALUE;\n            }\n        } else {\n            if (approvedSignatures[keccak256(_data)] == keccak256(_signature)) {\n                return EIP1271_MAGIC_VALUE;\n            }\n        }\n        return \"0x\";\n    }\n\n    /**\n     * @dev               Get the byte hash of function call i.e. first four bytes of data\n     * @param data        encoded transaction data.\n     */\n    function _getFunctionHashFromData(bytes memory data)\n        private\n        pure\n        returns (bytes4 functionHash)\n    {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            functionHash := mload(add(data, 32))\n        }\n    }\n\n    /**\n     * @dev                encode message with contants\n     * @param message      the message that needs to be encoded\n     */\n    function _encodeMessageHash(bytes32 message)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes32 safeMessageHash = keccak256(abi.encode(MSG_TYPEHASH, message));\n        return\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x23),\n                keccak256(\n                    abi.encode(DOMAIN_SEPARATOR_TYPEHASH, safeMessageHash)\n                )\n            );\n    }\n\n    /**\n     * @dev                set new safe\n     * @param _safe        safe address\n     */\n    function setSafe(address _safe) public onlySafe {\n        require(_safe != address(0), \"Signer: Safe zero address\");\n        safe = _safe;\n    }\n\n    /**\n     * @dev                      add new contracts and functions\n     * @param _contract          contract address\n     * @param _functionSignature function signature for the contract\n     */\n    function approveNewTransaction(address _contract, bytes4 _functionSignature)\n        external\n        onlySafe\n    {\n        require(_contract != address(0), \"Signer: contract address zero\");\n        require(\n            _functionSignature != bytes4(0),\n            \"Signer: function signature zero\"\n        );\n        allowedTransactions[_contract][_functionSignature] = true;\n    }\n\n    /**\n     * @dev                      add new contracts and functions\n     * @param _contract           contract address\n     * @param _functionSignature function signature for the contract\n     */\n    function removeAllowedTransaction(\n        address _contract,\n        bytes4 _functionSignature\n    ) external onlySafe {\n        // solhint-disable-next-line reason-string\n        require(\n            allowedTransactions[_contract][_functionSignature] == true,\n            \"Signer: only approved transactions can be removed\"\n        );\n        allowedTransactions[_contract][_functionSignature] = false;\n    }\n}\n"
    },
    "contracts/utils/interface/Safe.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n/* solium-disable */\npragma solidity 0.8.9;\n\ncontract Enum {\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n}\n\ninterface Safe {\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes calldata data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address refundReceiver,\n        uint256 _nonce\n    ) external view returns (bytes32);\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\ncontract ISignatureValidatorConstants {\n    // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\n}\n\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _data Arbitrary length data signed on the behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\n}\n"
    },
    "contracts/utils/Signer.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n// solium-disable linebreak-style\npragma solidity 0.8.9;\n\nimport \"./interface/Safe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/interfaces/ISignatureValidator.sol\";\n\n/**\n * @title PrimeDAO Signer Contract\n * @dev   Enables signing SeedFactory.deploySeed() transaction before sending it to Gnosis Safe.\n */\ncontract Signer is ISignatureValidator {\n    // SeedFactory.deploySeed() byte hash\n    bytes4 internal constant SEED_FACTORY_MAGIC_VALUE = 0xda235e6e;\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\n        0x7a9f5b2bf4dbb53eb85e012c6094a3d71d76e5bfe821f44ab63ed59311264e35;\n    bytes32 private constant SEED_MSG_TYPEHASH =\n        0xa1a7ad659422d5fc08fdc481fd7d8af8daf7993bc4e833452b0268ceaab66e5d;\n\n    mapping(bytes32 => bytes32) public approvedSignatures;\n\n    /* solium-disable */\n    address public immutable safe;\n    address public immutable seedFactory;\n    /* solium-enable */\n\n    event SignatureCreated(bytes signature, bytes32 indexed hash);\n\n    /**\n     * @dev                Signer Constructor\n     * @param _safe        Gnosis Safe address.\n     * @param _seedFactory Seed Factory address.\n     */\n    constructor(address _safe, address _seedFactory) {\n        require(\n            _safe != address(0) && _seedFactory != address(0),\n            \"Signer: Safe and SeedFactory address cannot be zero\"\n        );\n        safe = _safe;\n        seedFactory = _seedFactory;\n    }\n\n    /**\n     * @dev                   Signature generator\n     * @param _to             receiver address.\n     * @param _value          value in wei.\n     * @param _data           encoded transaction data.\n     * @param _operation      type of operation call.\n     * @param _safeTxGas      safe transaction gas for gnosis safe.\n     * @param _baseGas        base gas for gnosis safe.\n     * @param _gasPrice       gas price for gnosis safe transaction.\n     * @param _gasToken       token which gas needs to paid for gnosis safe transaction.\n     * @param _refundReceiver address account to receive refund for remaining gas.\n     * @param _nonce          gnosis safe contract nonce.\n     */\n    function generateSignature(\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        Enum.Operation _operation,\n        uint256 _safeTxGas,\n        uint256 _baseGas,\n        uint256 _gasPrice,\n        address _gasToken,\n        address _refundReceiver,\n        uint256 _nonce\n    ) external returns (bytes memory signature, bytes32 hash) {\n        // check if transaction parameters are correct\n        require(\n            _to == seedFactory,\n            \"Signer: cannot sign transaction transaction to invalid seedFactory\"\n        );\n        require(\n            _getFunctionHashFromData(_data) == SEED_FACTORY_MAGIC_VALUE,\n            \"Signer: can only sign calls to deploySeed\"\n        );\n        require(\n            _value == 0 &&\n                _refundReceiver == address(0) &&\n                _operation == Enum.Operation.Call,\n            \"Signer: invalid arguments provided\"\n        );\n\n        // get contractTransactionHash from gnosis safe\n        hash = Safe(safe).getTransactionHash(\n            _to,\n            0,\n            _data,\n            _operation,\n            _safeTxGas,\n            _baseGas,\n            _gasPrice,\n            _gasToken,\n            _refundReceiver,\n            _nonce\n        );\n\n        bytes memory paddedAddress = bytes.concat(\n            bytes12(0),\n            bytes20(address(this))\n        );\n        bytes memory messageHash = _encodeMessageHash(hash);\n        // check if transaction is not signed before\n        require(\n            approvedSignatures[hash] != keccak256(messageHash),\n            \"Signer: transaction already signed\"\n        );\n\n        // generate signature and add it to approvedSignatures mapping\n        signature = bytes.concat(\n            paddedAddress,\n            bytes32(uint256(65)),\n            bytes1(0),\n            bytes32(uint256(messageHash.length)),\n            messageHash\n        );\n        approvedSignatures[hash] = keccak256(messageHash);\n        emit SignatureCreated(signature, hash);\n    }\n\n    /**\n     * @dev                Validate signature using EIP1271\n     * @param _data        Encoded transaction hash supplied to verify signature.\n     * @param _signature   Signature that needs to be verified.\n     */\n    function isValidSignature(bytes memory _data, bytes memory _signature)\n        public\n        view\n        virtual\n        override\n        returns (bytes4)\n    {\n        if (_data.length == 32) {\n            bytes32 hash;\n            assembly {\n                hash := mload(add(_data, 32))\n            }\n            if (approvedSignatures[hash] == keccak256(_signature)) {\n                return EIP1271_MAGIC_VALUE;\n            }\n        } else {\n            if (approvedSignatures[keccak256(_data)] == keccak256(_signature)) {\n                return EIP1271_MAGIC_VALUE;\n            }\n        }\n        return \"0x\";\n    }\n\n    /**\n     * @dev               Get the byte hash of function call i.e. first four bytes of data\n     * @param data        encoded transaction data.\n     */\n    function _getFunctionHashFromData(bytes memory data)\n        private\n        pure\n        returns (bytes4 functionHash)\n    {\n        assembly {\n            functionHash := mload(add(data, 32))\n        }\n    }\n\n    /**\n     * @dev                encode message with contants\n     * @param message      the message that needs to be encoded\n     */\n    function _encodeMessageHash(bytes32 message)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes32 safeMessageHash = keccak256(\n            abi.encode(SEED_MSG_TYPEHASH, message)\n        );\n        return\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x23),\n                keccak256(\n                    abi.encode(DOMAIN_SEPARATOR_TYPEHASH, safeMessageHash)\n                )\n            );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}