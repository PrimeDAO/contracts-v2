{
  "language": "Solidity",
  "sources": {
    "contracts/seed/Seed.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n/* solhint-disable space-after-comma */\n/* solhint-disable max-states-count */\n// solium-disable linebreak-style\npragma solidity 0.8.4;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @title PrimeDAO Seed contract\n * @dev   Smart contract for seed phases of liquid launch.\n */\ncontract Seed {\n    // Locked parameters\n    address public beneficiary;\n    address public admin;\n    uint256 public softCap;\n    uint256 public hardCap;\n    uint256 public seedAmountRequired;    // Amount of seed required for distribution\n    uint256 public feeAmountRequired;     // Amount of seed required for fee\n    uint256 public price;\n    uint256 public startTime;\n    uint256 public endTime;               // set by project admin, this is the last resort endTime to be applied when\n                                          //     maximumReached has not been reached by then\n    bool    public permissionedSeed;\n    uint32  public vestingDuration;\n    uint32  public vestingCliff;\n    IERC20  public seedToken;\n    IERC20  public fundingToken;\n    uint8   public fee;\n\n    bytes   public metadata;           // IPFS Hash\n\n    uint256 constant internal PCT_BASE        = 10 ** 18;  // // 0% = 0; 1% = 10 ** 16; 100% = 10 ** 18\n\n    // Contract logic\n    bool    public closed;                 // is the distribution closed\n    bool    public paused;                 // is the distribution paused\n    bool    public isFunded;               // distribution can only start when required seed tokens have been funded\n    bool    public initialized;            // is this contract initialized [not necessary that it is funded]\n    bool    public minimumReached;         // if the softCap[minimum limit of funding token] is reached\n    bool    public maximumReached;         // if the hardCap[maximum limit of funding token] is reached\n    uint256 public vestingStartTime;       // timestamp for when vesting starts, by default == endTime,\n                                           //     otherwise when maximumReached is reached\n    uint256 public totalFunderCount;       // Total funders that have contributed.\n    uint256 public seedRemainder;          // Amount of seed tokens remaining to be distributed\n    uint256 public seedClaimed;            // Amount of seed token claimed by the user.\n    uint256 public feeRemainder;           // Amount of seed tokens remaining for the fee\n    uint256 public feeClaimed;             // Amount of seed tokens claimed as fee\n    uint256 public fundingCollected;       // Amount of funding tokens collected by the seed contract.\n    uint256 public fundingWithdrawn;       // Amount of funding token withdrawn from the seed contract.\n\n    mapping (address => bool) public whitelisted;        // funders that are whitelisted and allowed to contribute\n    mapping (address => FunderPortfolio) public funders; // funder address to funder portfolio\n\n    event SeedsPurchased(address indexed recipient, uint256 amountPurchased);\n    event TokensClaimed(address indexed recipient,uint256 amount,address indexed beneficiary,uint256 feeAmount);\n    event FundingReclaimed(address indexed recipient, uint256 amountReclaimed);\n    event MetadataUpdated(bytes indexed metadata);\n\n    struct FunderPortfolio {\n        uint256 seedAmount;                 // Total amount of seed tokens bought\n        uint256 totalClaimed;               // Total amount of seed tokens claimed\n        uint256 fundingAmount;              // Total amount of funding tokens contributed\n        uint256 fee;                        // Total amount of fee in seed amount for this portfolio\n        uint256 feeClaimed;                 // Total amount of fee sent to beneficiary for this portfolio\n    }\n\n    modifier initializer() {\n        require(!initialized, \"Seed: contract already initialized\");\n        initialized = true;\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Seed: caller should be admin\");\n        _;\n    }\n\n    modifier isActive() {\n        require(!closed, \"Seed: should not be closed\");\n        require(!paused, \"Seed: should not be paused\");\n        _;\n    }\n\n    modifier allowedToBuy() {\n        require(!maximumReached, \"Seed: maximum funding reached\");\n        require(!permissionedSeed || whitelisted[msg.sender], \"Seed: sender has no rights\");\n        require(endTime >= block.timestamp && startTime <= block.timestamp,\n            \"Seed: only allowed during distribution period\");\n        _;\n    }\n\n    modifier allowedToClaim() {\n        require(minimumReached, \"Seed: minimum funding amount not met\");\n        require(endTime <= block.timestamp || maximumReached,\"Seed: the distribution has not yet finished\");\n        _;\n    }\n\n    modifier allowedToRetrieve() {\n        require(!paused, \"Seed: should not be paused\");\n        require(startTime <= block.timestamp, \"Seed: distribution haven't started\");\n        require(!minimumReached, \"Seed: minimum already met\");\n        _;\n    }\n\n    modifier allowedToWithdraw() {\n        require(!paused, \"Seed: should not be paused\");\n        require(minimumReached, \"Seed: minimum funding amount not met\");\n        _;\n    }\n\n    /**\n      * @dev                          Initialize Seed.\n      * @param _beneficiary           The address that recieves fees.\n      * @param _admin                 The address of the admin of this contract. Funds contract\n                                      and has permissions to whitelist users, pause and close contract.\n      * @param _tokens                Array containing two params:\n                                        - The address of the seed token being distributed.\n      *                                 - The address of the funding token being exchanged for seed token.\n      * @param _softHardThresholds     Array containing two params:\n                                        - the minimum funding token collection threshold in wei denomination.\n                                        - the highest possible funding token amount to be raised in wei denomination.\n      * @param _price                 The price in wei of fundingTokens when exchanged for seedTokens.\n      * @param _startTime             Distribution start time in unix timecode.\n      * @param _endTime               Distribution end time in unix timecode.\n      * @param _vestingDuration       Vesting period duration in seconds.\n      * @param _vestingCliff          Cliff duration in seconds.\n      * @param _permissionedSeed      Set to true if only whitelisted adresses are allowed to participate.\n      * @param _fee                   Success fee expressed as a % (e.g. 2 = 2% fee)\n    */\n    function initialize(\n        address _beneficiary,\n        address _admin,\n        address[] memory _tokens,\n        uint256[] memory _softHardThresholds,\n        uint256 _price,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint32  _vestingDuration,\n        uint32  _vestingCliff,\n        bool    _permissionedSeed,\n        uint8   _fee\n    ) public initializer\n    {\n\n        // parameter check\n        require(_tokens[0] != _tokens[1], \"SeedFactory: seedToken cannot be fundingToken\");\n        require(_softHardThresholds[1] >= _softHardThresholds[0],\"SeedFactory: hardCap cannot be less than softCap\");\n        require(_vestingDuration >= _vestingCliff, \"SeedFactory: vestingDuration cannot be less than vestingCliff\");\n        require(_endTime > _startTime, \"SeedFactory: endTime cannot be less than equal to startTime\");\n\n        beneficiary       = _beneficiary;\n        admin             = _admin;\n        softCap           = _softHardThresholds[0];\n        hardCap           = _softHardThresholds[1];\n        price             = _price;\n        startTime         = _startTime;\n        endTime           = _endTime;\n        vestingStartTime  = endTime;\n        vestingDuration   = _vestingDuration;\n        vestingCliff      = _vestingCliff;\n        permissionedSeed  = _permissionedSeed;\n        seedToken         = IERC20(_tokens[0]);\n        fundingToken      = IERC20(_tokens[1]);\n        fee               = _fee;\n\n        seedAmountRequired = (hardCap*PCT_BASE) / _price;\n        feeAmountRequired  = (seedAmountRequired*_fee) / 100;\n        seedRemainder      = seedAmountRequired;\n        feeRemainder       = feeAmountRequired;\n    }\n\n    /**\n      * @dev                     Buy seed tokens.\n      * @param _fundingAmount    The amount of funding tokens to contribute.\n    */\n    function buy(uint256 _fundingAmount) public isActive allowedToBuy returns(uint256, uint256) {\n        if (!isFunded) {\n            require(seedToken.balanceOf(address(this)) >= seedAmountRequired + feeAmountRequired,\n                \"Seed: sufficient seeds not provided\");\n            isFunded = true;\n        }\n        // fundingAmount is an amount of fundingTokens required to buy _seedAmount of SeedTokens\n        uint256 seedAmount = (_fundingAmount*PCT_BASE)/price;\n\n        // Funding Token balance of this contract;\n        uint256 fundingBalance = fundingCollected;\n\n        // feeAmount is an amount of fee we are going to get in seedTokens\n        uint256 feeAmount = (seedAmount*fee) / 100;\n\n        // total fundingAmount should not be greater than the hardCap\n        require( fundingBalance + _fundingAmount <= hardCap,\n            \"Seed: amount exceeds contract sale hardCap\");\n\n        require( seedRemainder >= seedAmount,\n            \"Seed: seed distribution would be exceeded\");\n\n        fundingCollected = fundingBalance + _fundingAmount;\n\n        // the amount of seed tokens still to be distributed\n        seedRemainder -= seedAmount;\n        feeRemainder  -= feeAmount;\n\n        // Here we are sending amount of tokens to pay for seed tokens to purchase\n        require(fundingToken.transferFrom(msg.sender, address(this), _fundingAmount), \"Seed: no tokens\");\n\n        if (fundingCollected >= softCap) {\n            minimumReached = true;\n        }\n        if (fundingCollected >= hardCap) {\n            maximumReached = true;\n            vestingStartTime = _currentTime();\n        }\n\n        _addFunder(\n            msg.sender,\n            (funders[msg.sender].seedAmount + seedAmount),         // Previous Seed Amount + new seed amount\n            (funders[msg.sender].fundingAmount + _fundingAmount),  // Previous Funding Amount + new funding amount\n            funders[msg.sender].totalClaimed,\n            (funders[msg.sender].fee + feeAmount),                  // Previous Fee + new fee\n            funders[msg.sender].feeClaimed\n            );\n\n        // buyer, seed token purchased in this transaction (not the total amount of seed purchased)\n        emit SeedsPurchased(msg.sender, seedAmount);\n\n        return (seedAmount, feeAmount);\n    }\n\n    /**\n      * @dev                     Claim vested seed tokens.\n      * @param _funder           Address of funder to calculate seconds and amount claimable\n      * @param _claimAmount      The amount of seed token a users wants to claim.\n    */\n    function claim(address _funder, uint256 _claimAmount) public allowedToClaim returns(uint256) {\n        uint256 amountClaimable;\n\n        amountClaimable = calculateClaim(_funder);\n        require(amountClaimable > 0, \"Seed: amount claimable is 0\");\n        require(amountClaimable >= _claimAmount, \"Seed: request is greater than claimable amount\");\n        uint256 feeAmountOnClaim = (_claimAmount * fee) / 100;\n\n        FunderPortfolio memory tokenFunder = funders[_funder];\n\n        tokenFunder.totalClaimed    += _claimAmount;\n        tokenFunder.feeClaimed      += feeAmountOnClaim;\n        funders[_funder] = tokenFunder;\n\n        seedClaimed += _claimAmount;\n        feeClaimed  += feeAmountOnClaim;\n        require(seedToken.transfer(beneficiary, feeAmountOnClaim), \"Seed: cannot transfer to beneficiary\");\n        require(seedToken.transfer(_funder, _claimAmount), \"Seed: no tokens\");\n\n        emit TokensClaimed(_funder, _claimAmount, beneficiary, feeAmountOnClaim);\n\n        // fee on the distributed reward collected from admin\n        return (feeAmountOnClaim);\n    }\n\n    /**\n      * @dev         Returns funding tokens to user.\n    */\n    function retrieveFundingTokens() public allowedToRetrieve returns(uint256) {\n        require(funders[msg.sender].fundingAmount > 0, \"Seed: zero funding amount\");\n        FunderPortfolio memory tokenFunder = funders[msg.sender];\n        uint256 fundingAmount = tokenFunder.fundingAmount;\n        seedRemainder += tokenFunder.seedAmount;\n        feeRemainder += tokenFunder.fee;\n        tokenFunder.seedAmount    = 0;\n        tokenFunder.fee           = 0;\n        tokenFunder.fundingAmount = 0;\n        funders[msg.sender]  = tokenFunder;\n        fundingCollected -= fundingAmount;\n        require(\n            fundingToken.transfer(msg.sender, fundingAmount),\n            \"Seed: cannot return funding tokens to msg.sender\"\n        );\n        emit FundingReclaimed(msg.sender, fundingAmount);\n\n        return fundingAmount;\n    }\n\n    // ADMIN ACTIONS\n\n    /**\n      * @dev                     Pause distribution.\n    */\n    function pause() public onlyAdmin isActive {\n        paused = true;\n    }\n\n    /**\n      * @dev                     Unpause distribution.\n    */\n    function unpause() public onlyAdmin {\n        require(closed != true, \"Seed: should not be closed\");\n        require(paused == true, \"Seed: should be paused\");\n\n        paused = false;\n    }\n\n    /**\n      * @dev                     Close distribution.\n    */\n    function close() public onlyAdmin isActive {\n        // transfer seed tokens back to admin\n        if (minimumReached) {\n            // remaining seeds = seedRemainder + feeRemainder\n            uint256 seedToTransfer = seedRemainder+feeRemainder;\n            require(\n                seedToken.transfer(admin, seedToTransfer),\n                \"Seed: should transfer seed tokens to admin\"\n            );\n            paused = false;\n        } else {\n            require(\n                seedToken.transfer(admin, seedAmountRequired+feeAmountRequired),\n                \"Seed: should transfer seed tokens to admin\"\n            );\n            closed = true;\n            paused = false;\n        }\n    }\n\n    /**\n      * @dev                     Add address to whitelist.\n      * @param _buyer            Address which needs to be whitelisted\n    */\n    function whitelist(address _buyer) public onlyAdmin isActive {\n        require(permissionedSeed == true, \"Seed: module is not whitelisted\");\n\n        whitelisted[_buyer] = true;\n    }\n\n    /**\n      * @dev                     Add multiple addresses to whitelist.\n      * @param _buyers           Array of addresses to whitelist addresses in batch\n    */\n    function whitelistBatch(address[] memory _buyers) public onlyAdmin isActive {\n        require(permissionedSeed == true, \"Seed: module is not whitelisted\");\n        for (uint256 i = 0; i < _buyers.length; i++) {\n            whitelisted[_buyers[i]] = true;\n        }\n    }\n\n    /**\n      * @dev                     Remove address from whitelist.\n      * @param buyer             Address which needs to be unwhitelisted\n    */\n    function unwhitelist(address buyer) public onlyAdmin isActive {\n        require(permissionedSeed == true, \"Seed: module is not whitelisted\");\n\n        whitelisted[buyer] = false;\n    }\n\n    /**\n      * @dev                     Withdraw funds from the contract\n    */\n    function withdraw() public onlyAdmin allowedToWithdraw {\n        uint pendingFundingBalance = fundingCollected - fundingWithdrawn;\n        fundingWithdrawn = fundingCollected;\n        fundingToken.transfer(msg.sender, pendingFundingBalance);\n    }\n\n    /**\n      * @dev                     Updates metadata.\n      * @param _metadata         Seed contract metadata, that is IPFS Hash\n    */\n    function updateMetadata(bytes memory _metadata) public {\n        require(\n            initialized != true || msg.sender == admin,\n            \"Seed: contract should not be initialized or caller should be admin\"\n        );\n        metadata = _metadata;\n        emit MetadataUpdated(_metadata);\n    }\n\n    // GETTER FUNCTIONS\n    /**\n      * @dev                     Calculates the maximum claim\n      * @param _funder           Address of funder to find the maximum claim\n    */\n    function calculateClaim(address _funder) public view returns(uint256) {\n        FunderPortfolio memory tokenFunder = funders[_funder];\n\n        if (_currentTime() < vestingStartTime) {\n            return 0;\n        }\n\n        // Check cliff was reached\n        uint256 elapsedSeconds = _currentTime() - vestingStartTime;\n\n        if (elapsedSeconds < vestingCliff) {\n            return 0;\n        }\n\n        // If over vesting duration, all tokens vested\n        if (elapsedSeconds >= vestingDuration) {\n            return tokenFunder.seedAmount - tokenFunder.totalClaimed;\n        } else {\n            uint256 amountVested = (elapsedSeconds*tokenFunder.seedAmount) / vestingDuration;\n            return amountVested - tokenFunder.totalClaimed;\n        }\n    }\n\n    /**\n      * @dev                     check whitelist status of a buyer\n      * @param _buyer            address of buyer to check status\n    */\n    function checkWhitelisted(address _buyer) public view returns(bool) {\n        return whitelisted[_buyer];\n    }\n\n    // INTERNAL FUNCTIONS\n    /**\n      * @dev                      get current time or block.timestamp\n    */\n    function _currentTime() internal view returns(uint256) {\n        return block.timestamp;\n    }\n\n    /**\n      * @dev                      add/update funder portfolio\n      * @param _recipient         Address of funder recipient\n      * @param _seedAmount        seed amount of the funder\n      * @param _fundingAmount     funding amount contributed\n      * @param _totalClaimed      total seed token amount claimed\n      * @param _fee               fee on seed amount bought\n    */\n    function _addFunder(\n        address _recipient,\n        uint256 _seedAmount,\n        uint256 _fundingAmount,\n        uint256 _totalClaimed,\n        uint256 _fee,\n        uint256 _feeClaimed\n    )\n    internal\n    {\n\n        require(_seedAmount >= vestingDuration, \"Seed: amountVestedPerSecond > 0\");\n\n        funders[_recipient] = FunderPortfolio({\n            seedAmount: _seedAmount,\n            totalClaimed: _totalClaimed,\n            fundingAmount: _fundingAmount,\n            fee: _fee,\n            feeClaimed: _feeClaimed\n        });\n        totalFunderCount++;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/seed/SeedFactory.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n// solium-disable linebreak-style\n/* solhint-disable space-after-comma */\n\npragma solidity 0.8.4;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\nimport \"./Seed.sol\";\nimport \"../utils/CloneFactory.sol\";\n\n\n/**\n * @title PrimeDAO Seed Factory\n * @dev   Enable PrimeDAO governance to create new Seed contracts.\n */\ncontract SeedFactory is CloneFactory, Ownable {\n\n    Seed public masterCopy;\n\n    event SeedCreated(address indexed newSeed, address indexed beneficiary);\n\n    /**\n     * @dev               Set Seed contract which works as a base for clones.\n     * @param _masterCopy The address of the new Seed basis.\n     */\n    function setMasterCopy(Seed _masterCopy) public onlyOwner {\n        require(address(_masterCopy) != address(0), \"SeedFactory: new mastercopy cannot be zero address\");\n        masterCopy = _masterCopy;\n    }\n\n    /**\n      * @dev                                Deploys Seed contract.\n      * @param _beneficiary                 The address that recieves fees.\n      * @param _admin                       The address of the admin of this contract. Funds contract\n                                            and has permissions to whitelist users, pause and close contract.\n      * @param _tokens                      Array containing two params:\n                                                - The address of the seed token being distributed.\n      *                                         - The address of the funding token being exchanged for seed token.\n      * @param _softHardThresholds          Array containing two params:\n                                                - the minimum funding token collection threshold in wei denomination.\n                                                - the highest possible funding token amount to be raised in wei denomination.\n      * @param _price                       1 Funding Token = _price amount of Seed Token.\n      * @param _startTime                   Distribution start time in unix timecode.\n      * @param _endTime                     Distribution end time in unix timecode.\n      * @param _vestingDurationAndCliff       Array containing two params:\n                                                - Vesting period duration in days.\n                                                - Cliff duration in days.\n      * @param _permissionedSeed      Set to true if only whitelisted adresses are allowed to participate.\n      * @param _fee                   Success fee expressed in Wei as a % (e.g. 2 = 2% fee)\n      * @param _metadata              Seed contract metadata, that is IPFS URI\n    */\n    function deploySeed(\n        address _beneficiary,\n        address _admin,\n        address[] memory _tokens,\n        uint256[] memory _softHardThresholds,\n        uint256 _price,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint32[] memory _vestingDurationAndCliff,\n        bool  _permissionedSeed,\n        uint8 _fee,\n        bytes memory _metadata\n    ) public onlyOwner returns (address)\n    {\n        {\n            require(address(masterCopy) != address(0), \"SeedFactory: mastercopy cannot be zero address\");\n            require(_vestingDurationAndCliff.length == 2, \"SeedFactory: Hasn't provided both vesting duration and cliff\");\n        }\n\n        // deploy clone\n        address _newSeed = createClone(address(masterCopy));\n\n        Seed(_newSeed).updateMetadata(_metadata);\n\n        // initialize\n        Seed(_newSeed).initialize(\n            _beneficiary,\n            _admin,\n            _tokens,\n            _softHardThresholds,\n            _price,\n            _startTime,\n            _endTime,\n            _vestingDurationAndCliff[0],\n            _vestingDurationAndCliff[1],\n            _permissionedSeed,\n            _fee\n        );\n\n        emit SeedCreated(address(_newSeed), msg.sender);\n\n        return _newSeed;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/utils/CloneFactory.sol": {
      "content": "/*\n\n██████╗░██████╗░██╗███╗░░░███╗███████╗██████╗░░█████╗░░█████╗░\n██╔══██╗██╔══██╗██║████╗░████║██╔════╝██╔══██╗██╔══██╗██╔══██╗\n██████╔╝██████╔╝██║██╔████╔██║█████╗░░██║░░██║███████║██║░░██║\n██╔═══╝░██╔══██╗██║██║╚██╔╝██║██╔══╝░░██║░░██║██╔══██║██║░░██║\n██║░░░░░██║░░██║██║██║░╚═╝░██║███████╗██████╔╝██║░░██║╚█████╔╝\n╚═╝░░░░░╚═╝░░╚═╝╚═╝╚═╝░░░░░╚═╝╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░\n\n* ===========\n*\n* CloneFactory.sol was originally published under MIT license.\n* Republished by PrimeDAO under GNU General Public License v3.0.\n*\n*/\n\n// SPDX-License-Identifier: GPL-3.0-or-later\n// solium-disable linebreak-style\n// solhint-disable max-line-length\n// solhint-disable no-inline-assembly\n\npragma solidity 0.8.4;\n\ncontract CloneFactory {\n\n    function createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n    }\n\n    function isClone(address target, address query) internal view returns (bool result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(\n            eq(mload(clone), mload(other)),\n            eq(mload(add(clone, 0xd)), mload(add(other, 0xd)))\n            )\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}